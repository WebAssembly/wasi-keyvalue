// A generic keyvalue interface for WASI.
interface types {
	/// A bucket is a collection of key-value pairs. Each key-value pair is stored
	/// as a entry in the bucket, and the bucket itself acts as a collection of all
	/// these entries. 
	///
	/// It is worth noting that the exact terminology for bucket in key-value stores
	/// can very depending on the specific implementation. For example,
	/// 1. Amazon DynamoDB calls a collection of key-value pairs a table
	/// 2. Redis has hashes, sets, and sorted sets as different types of collections
	/// 3. Cassandra calls a collection of key-value pairs a column family
	/// 4. MongoDB calls a collection of key-value pairs a collection
	/// 5. Riak calls a collection of key-value pairs a bucket
	/// 6. Memcached calls a collection of key-value pairs a slab
	/// 7. Azure Cosmos DB calls a collection of key-value pairs a container
	///
	/// In this interface, we use the term `bucket` to refer to a collection of key-value
	// Soon: switch to `resource bucket { ... }`
	type bucket = u32
	drop-bucket: func(bucket: bucket)
	open-bucket: func(name: string) -> result<bucket, error>

	/// A key is a unique identifier for a value in a bucket. The key is used to
	/// retrieve the value from the bucket.
	type key = string

	/// A list of keys
	type keys = list<key>
	
	/// An error resource type for keyvalue operations.
	/// Currently, this provides only one function to return a string representation
	/// of the error. In the future, this will be extended to provide more information
	/// about the error.
	// Soon: switch to `resource error { ... }`
	type error = u32
	drop-error: func(error: error)
	trace: func(error: error) -> string

	use pkg.wasi-io.{input-stream, output-stream}

	/// A value is the data stored in a key-value pair. The value can be of any type
	/// that can be represented in a byte array. It provides a way to write the value
	/// to the output-stream defined in the `wasi-io` interface.
	// Soon: switch to `resource value { ... }`
	type outgoing-value = u32
	drop-outgoing-value: func(outgoing-value: outgoing-value)
	new-outgoing-value: func() -> outgoing-value
	outgoing-value-write-body: func(outgoing-value: outgoing-value) -> result<output-stream>

	/// A incoming-value is a wrapper around a value. It provides a way to read the value
	/// from the input-stream defined in the `wasi-io` interface.
	///
	/// The incoming-value provides two ways to consume the value:
	/// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the
	///    value as a list of bytes.
	/// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the
	///    value as an input-stream.
	// Soon: switch to `resource incoming-value { ... }`
	type incoming-value = u32
	type incoming-value-async-body = input-stream
	type incoming-value-sync-body = list<u8>
	drop-incoming-value: func(incoming-value: incoming-value)
	incoming-value-consume-sync: func(incoming-value: incoming-value) -> result<incoming-value-sync-body, error>
	incoming-value-consume-async: func(incoming-value: incoming-value) -> result<incoming-value-async-body, error>
	size: func(incoming-value: incoming-value) -> u64
}

/// A keyvalue interface that provides simple read and write operations.
interface keyvalue-readwrite {
	/// A keyvalue interface that provides simple read and write operations.
	use self.types.{bucket, error, incoming-value, key, outgoing-value}
	
	/// Get the value associated with the key in the bucket. It returns a incoming-value
	/// that can be consumed to get the value.
	///
	/// If the key does not exist in the bucket, it returns an error.
	get: func(bucket: bucket, key: key) -> result<incoming-value, error>

	/// Set the value associated with the key in the bucket. If the key already
	/// exists in the bucket, it overwrites the value.
	///
	/// If the key does not exist in the bucket, it creates a new key-value pair.
	/// If any other error occurs, it returns an error.
	set: func(bucket: bucket, key: key, outgoing-value: outgoing-value) -> result<_, error>

	/// Delete the key-value pair associated with the key in the bucket.
	///
	/// If the key does not exist in the bucket, it returns an error.
	delete: func(bucket: bucket, key: key) -> result<_, error>

	/// Check if the key exists in the bucket.
	///
	/// If the key does not exist in the bucket, it returns an error.
	exists: func(bucket: bucket, key: key) -> result<bool, error>
}

/// A keyvalue interface that provides atomic operations.
interface keyvalue-atomic {
	/// A keyvalue interface that provides atomic operations.
	use self.types.{bucket, error, key}

	/// Atomically increment the value associated with the key in the bucket by the 
	/// given delta. It returns the new value.
	///
	/// If the key does not exist in the bucket, it creates a new key-value pair
	/// with the value set to the given delta. 
	///
	/// If any other error occurs, it returns an error.
	increment: func(bucket: bucket, key: key, delta: u64) -> result<u64, error>
	
	/// Atomically compare and swap the value associated with the key in the bucket.
	/// It returns a boolean indicating if the swap was successful.
	///
	/// If the key does not exist in the bucket, it returns an error.
	compare-and-swap: func(bucket: bucket, key: key, old: u64, new: u64) -> result<bool, error>
}

/// A keyvalue interface that provides batch operations.
interface keyvalue-batch {
	/// A keyvalue interface that provides batch get operations.
	use self.types.{bucket, error, key, keys, incoming-value, outgoing-value}

	/// Get the values associated with the keys in the bucket. It returns a list of
	/// incoming-values that can be consumed to get the values.
	///
	/// If any of the keys do not exist in the bucket, it returns an error.
	get-many: func(bucket: bucket, keys: keys) -> result<list<incoming-value>, error>

	/// Get all the keys in the bucket. It returns a list of keys.
	get-keys: func(bucket: bucket) -> keys

	/// Set the values associated with the keys in the bucket. If the key already
	/// exists in the bucket, it overwrites the value.
	///
	/// If any of the keys do not exist in the bucket, it creates a new key-value pair.
	/// If any other error occurs, it returns an error.
	set-many: func(bucket: bucket, keys: keys, values: list<tuple<key, outgoing-value>>) -> result<_, error>

	/// Delete the key-value pairs associated with the keys in the bucket.
	///
	/// If any of the keys do not exist in the bucket, it skips the key.
	/// If any other error occurs, it returns an error.
	delete-many: func(bucket: bucket, keys: keys) -> result<_, error>
}

/// A keyvalue interface that provides handle-watch operations.
interface handle-watch {
	/// A keyvalue interface that provides handle-watch operations.
	use self.types.{bucket, key, incoming-value}

	/// Handle the set event for the given bucket and key. 
	/// It returns a incoming-value that can be consumed to get the value.
	on-set: func(bucket: bucket, key: key, incoming-value: incoming-value)

	/// Handle the delete event for the given bucket and key.
	on-delete: func(bucket: bucket, key: key)
}
