/// A keyvalue interface that provides eventually consistent key-value operations.
/// 
/// Each of these operations acts on a single key-value pair.
/// 
/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is
/// the common denominator for all data types defined by different key-value stores to handle data,
/// ensuring compatibility between different key-value stores. Note: the clients will be expecting
/// serialization/deserialization overhead to be handled by the key-value store. The value could be
/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.
///
/// ## Consistency
/// 
/// An implementation of this interface MUST be eventually consistent, meaning that, after some time
/// with no further updates, all replicas in the (potentially distributed) system will eventually
/// converge on a consistent state for all values.  This allows replicas to temporarily diverge to
/// ensure low latency and high availability.  Implementations based on a centralized or local
/// backing store may provide a stronger consistency model, but guest components which are intended
/// to be portable to any `wasi-keyvalue` implementation should not rely on anything stronger than
/// eventual consistency.
///
/// Given that each `bucket` resource may represent a connection to a different replica in a
/// distributed system, values read for a given key from two different `bucket`s may differ, even if
/// those `bucket` resources were opened using the same string identifier.  In addition, consecutive
/// operations on a single `bucket` resource may produce temporarily inconsistent results if
/// e.g. the implementation is forced to reconnect to a different replica due to a connection
/// failure.  For example, a write followed by a read may not return the value just written, even if
/// no other recent or subsequent writes have occurred.
///
/// Consider the following pseudocode example (and assume we start with an empty store and no other
/// concurrent activity):
///
/// ```
/// bucketA = open("foo")
/// bucketB = open("foo")
/// bucketA.set("bar", "a")
///
/// // These are guaranteed to succeed:
/// assert bucketA.get("bar").equals("a") or bucketA.get("bar") is None
/// assert bucketB.get("bar").equals("a") or bucketB.get("bar") is None
///
/// // This is likely to succeed, but not guaranteed; e.g. `bucketA` might need to reconnect to a
/// // different replica which hasn't received the above write yet.  It will _eventually_
/// // succeed, provided there are no irrecoverable errors which prevent the propagation of the
/// // write.
/// assert bucketA.get("bar").equals("a")
///
/// // Likewise, this will _eventually_ succeed in the absence of irrecoverable errors:
/// assert bucketB.get("bar").equals("a")
///
/// bucketB.set("bar", "b")
/// bucketC = open("foo")
/// value = bucketC.get("bar")
///
/// // This is guaranteed to succeed:
/// assert value.equals("a") or value.equals("b") or value is None
/// ```
///
/// In other words, the `bucketC` resource MAY reflect either the most recent write to the `bucketA`
/// resource, or the one to the `bucketB` resource, or neither, depending on how quickly either of
/// those writes reached the replica from which the `bucketC` resource is reading.  However,
/// assuming there are no irrecoverable errors -- such that the state of a replica is irretrievably
/// lost before it can be propagated -- one of the values ("a" or "b") MUST eventually be considered
/// the "latest" and replicated across the system, at which point all three resources will return
/// that same value.
///
/// ## Durability
///
/// This interface does not currently make any hard guarantees about the durability of values
/// stored.  A valid implementation might rely on an in-memory hash table, the contents of which are
/// lost when the process exits.  Alternatively, another implementation might synchronously persist
/// all writes to disk -- or even to a quorum of disk-backed nodes at multiple locations -- before
/// returning a result for a `set` call.  Finally, a third implementation might persist values
/// asynchronously on a best-effort basis without blocking `set` calls, in which case an I/O error
/// could occur after the component instance which originally made the call has exited.
///
/// Future versions of the `wasi-keyvalue` package may provide ways to query and control the
/// durability and consistency provided by the backing implementation.
interface store {
    /// The set of errors which may be raised by functions in this package
    variant error {
        /// The host does not recognize the store identifier requested.
        no-such-store,

        /// The requesting component does not have access to the specified store
        /// (which may or may not exist).
        access-denied,

        /// Some implementation-specific error has occurred (e.g. I/O)
        other(string)
    }

    /// A response to a `list-keys` operation.
    record key-response {
        /// The list of keys returned by the query.
        keys: list<string>,
        /// The continuation token to use to fetch the next page of keys. If this is `null`, then
        /// there are no more keys to fetch.
        cursor: option<string>
    }

    /// Get the bucket with the specified identifier.
    ///
    /// `identifier` must refer to a bucket provided by the host.
    ///
    /// `error::no-such-store` will be raised if the `identifier` is not recognized.
    open: func(identifier: string) -> result<bucket, error>;

    /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the
    /// bucket, and the bucket itself acts as a collection of all these entries.
    ///
    /// It is worth noting that the exact terminology for bucket in key-value stores can very
    /// depending on the specific implementation. For example:
    ///
    /// 1. Amazon DynamoDB calls a collection of key-value pairs a table
    /// 2. Redis has hashes, sets, and sorted sets as different types of collections
    /// 3. Cassandra calls a collection of key-value pairs a column family
    /// 4. MongoDB calls a collection of key-value pairs a collection
    /// 5. Riak calls a collection of key-value pairs a bucket
    /// 6. Memcached calls a collection of key-value pairs a slab
    /// 7. Azure Cosmos DB calls a collection of key-value pairs a container
    ///
    /// In this interface, we use the term `bucket` to refer to a connection to a collection of
    /// key-value pairs.
    ///
    /// Note that opening two `bucket` resources using the same identifier MAY result in connections
    /// to two separate replicas in a distributed database, and that writes to one of those
    /// resources are not guaranteed to be readable from the other resource promptly (or ever, in
    /// the case of a replica failure).  See the `Consistency` section of the `store` interface
    /// documentation for details.
    resource bucket {
        /// Get the value associated with the specified `key`
        ///
        /// The value is returned as an option. If the key-value pair exists in the
        /// store, it returns `Ok(value)`. If the key does not exist in the
        /// store, it returns `Ok(none)`. 
        ///
        /// If any other error occurs, it returns an `Err(error)`.
        get: func(key: string) -> result<option<list<u8>>, error>;

        /// Set the value associated with the key in the store. If the key already
        /// exists in the store, it overwrites the value.
        ///
        /// If the key does not exist in the store, it creates a new key-value pair.
        /// 
        /// If any other error occurs, it returns an `Err(error)`.
        set: func(key: string, value: list<u8>) -> result<_, error>;

        /// Delete the key-value pair associated with the key in the store.
        /// 
        /// If the key does not exist in the store, it does nothing.
        ///
        /// If any other error occurs, it returns an `Err(error)`.
        delete: func(key: string) -> result<_, error>;

        /// Check if the key exists in the store.
        /// 
        /// If the key exists in the store, it returns `Ok(true)`. If the key does
        /// not exist in the store, it returns `Ok(false)`.
        /// 
        /// If any other error occurs, it returns an `Err(error)`.
        exists: func(key: string) -> result<bool, error>;

        /// Get all the keys in the store with an optional cursor (for use in pagination). It
        /// returns a list of keys. Please note that for most KeyValue implementations, this is a
        /// can be a very expensive operation and so it should be used judiciously. Implementations
        /// can return any number of keys in a single response, but they should never attempt to
        /// send more data than is reasonable (i.e. on a small edge device, this may only be a few
        /// KB, while on a large machine this could be several MB). Any response should also return
        /// a cursor that can be used to fetch the next page of keys. See the `key-response` record
        /// for more information.
        /// 
        /// Note that the keys are not guaranteed to be returned in any particular order.
        /// 
        /// If the store is empty, it returns an empty list.
        /// 
        /// MAY show an out-of-date list of keys if there are concurrent writes to the store.
        /// 
        /// If any error occurs, it returns an `Err(error)`.
        list-keys: func(cursor: option<string>) -> result<key-response, error>;
    }
}
